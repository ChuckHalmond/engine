import { Injector } from "../../../patterns/injectors/Injector";
import { StackPool } from "../../../patterns/pools/StackPool";
import { EulerAngles } from "../angles/EulerAngles";
import { Matrix3 } from "../matrices/Matrix3";
import { Vector3 } from "../vectors/Vector3";
export { QuaternionValues };
export { Quaternion };
export { QuaternionInjector };
export { QuaternionBase };
export { QuaternionPool };
declare type QuaternionValues = [number, ...number[]] & {
    length: 4;
};
interface QuaternionConstructor {
    readonly prototype: Quaternion;
    new (): Quaternion;
    new (values: QuaternionValues): Quaternion;
    fromEuler(euler: EulerAngles): Quaternion;
    fromVector(vector: Vector3): Quaternion;
    fromMatrix(matrix: Matrix3): Quaternion;
}
interface Quaternion {
    readonly array: ArrayLike<number>;
    values: QuaternionValues;
    x: number;
    y: number;
    z: number;
    w: number;
    setArray(array: WritableArrayLike<number>): this;
    setValues(v: QuaternionValues): this;
    copy(quat: Quaternion): this;
    clone(): this;
    getAxis(out: Vector3): Vector3;
    setFromMatrix(matrix: Matrix3): Quaternion;
    toMatrix(): Matrix3;
    rotate(vec: Vector3): Vector3;
    setEuler(euler: EulerAngles): this;
    toEuler(): EulerAngles;
    toVector(): Vector3;
    setFromAxisAngle(axis: Vector3, angle: number): this;
    setFromVectors(from: Vector3, to: Vector3): this;
    angleTo(quat: Quaternion): number;
    rotateTowards(quat: Quaternion): this;
    invert(): this;
    conjugate(): this;
    dot(quat: Quaternion): number;
    lenSq(): number;
    len(): number;
    normalize(): this;
    add(quat: Quaternion): this;
    sub(quat: Quaternion): this;
    mult(quat: Quaternion): this;
    multScalar(scalar: number): this;
    slerp(quat: Quaternion, t: number): this;
    equals(quat: Quaternion): boolean;
    copyIntoArray(out: WritableArrayLike<number>, offset?: number): void;
    readFromArray(arr: ArrayLike<number>, offset?: number): void;
}
declare class QuaternionBase {
    protected _array: WritableArrayLike<number>;
    constructor();
    constructor(values: QuaternionValues);
    static fromVector(vector: Vector3): QuaternionBase;
    static fromEuler(eulerAngles: EulerAngles): QuaternionBase;
    get array(): ArrayLike<number>;
    get values(): QuaternionValues;
    set values(values: QuaternionValues);
    private get _x();
    private set _x(value);
    private get _y();
    private set _y(value);
    private set _z(value);
    private get _z();
    private set _w(value);
    private get _w();
    get x(): number;
    set x(x: number);
    get y(): number;
    set y(y: number);
    set z(z: number);
    get z(): number;
    set w(w: number);
    get w(): number;
    setArray(array: WritableArrayLike<number>): this;
    copy(quat: Quaternion): this;
    setValues(v: QuaternionValues): this;
    clone(): this;
    equals(quat: Quaternion): boolean;
    getAxis(out: Vector3): Vector3;
    toMatrix(): Matrix3;
    rotate(vec: Vector3): Vector3;
    toEuler(): EulerAngles;
    toVector(): Vector3;
    setEuler(eulerAngles: EulerAngles): this;
    setFromAxisAngle(axis: Vector3, angle: number): this;
    setFromMatrix(matrix: Matrix3): this;
    static fromMatrix(matrix: Matrix3): QuaternionBase;
    setFromVectors(from: Vector3, to: Vector3): this;
    dot(quat: Quaternion): number;
    lenSq(): number;
    len(): number;
    angleTo(quat: Quaternion): number;
    rotateTowards(quat: Quaternion): this;
    invert(): this;
    conjugate(): this;
    normalize(): this;
    add(quat: Quaternion): this;
    sub(quat: Quaternion): this;
    mult(quat: Quaternion): this;
    multScalar(scalar: number): this;
    slerp(quat: Quaternion, t: number): this;
    copyIntoArray(out: WritableArrayLike<number>, offset?: number): void;
    readFromArray(arr: ArrayLike<number>, offset?: number): void;
}
declare var Quaternion: QuaternionConstructor;
declare const QuaternionPool: StackPool<Quaternion>;
declare const QuaternionInjector: Injector<QuaternionConstructor>;
