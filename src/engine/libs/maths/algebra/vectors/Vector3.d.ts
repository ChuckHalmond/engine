import { Injector } from "../../../patterns/injectors/Injector";
import { Matrix3 } from "../matrices/Matrix3";
export { Vector3Constructor };
export { Vector3 };
export { Vector3Base };
export { Vector3Injector };
export declare type Vector3Values = [number, ...number[]] & {
    length: 3;
};
interface Vector3Constructor {
    readonly prototype: Vector3;
    new (): Vector3;
    new (x: number, y: number, z: number): Vector3;
    new (array: ArrayLike<number>): Vector3;
    angle(vectorA: Vector3, vectorB: Vector3): number;
}
interface Vector3 extends Iterable<number> {
    readonly array: Float32Array;
    values: Vector3Values;
    x: number;
    y: number;
    z: number;
    toString(): string;
    setValues(x: number, y: number, z: number): this;
    equals(vec: Vector3): boolean;
    copy(vec: Vector3): this;
    clone(): this;
    setUnit(): this;
    setZeros(): this;
    toCartesian(center: Vector3): this;
    toSpherical(center: Vector3): this;
    add(vec: Vector3): this;
    addScalar(k: number): this;
    sub(vec: Vector3): this;
    lerp(from: Vector3, to: Vector3, t: number): this;
    max(vecB: Vector3): this;
    min(vecB: Vector3): this;
    clamp(min: Vector3, max: Vector3): this;
    scale(k: number): this;
    cross(vec: Vector3): this;
    dot(vec: Vector3): number;
    length(): number;
    lengthSquared(): number;
    distance(vec: Vector3): number;
    distanceSquared(vec: Vector3): number;
    normalize(): this;
    negate(): this;
    mult(vec: Vector3): this;
    mult(mat: Matrix3): this;
    addScaled(vec: Vector3, k: number): this;
    copyAndSub(vecA: Vector3, vecB: Vector3): this;
    copyAndCross(vecA: Vector3, vecB: Vector3): this;
    writeIntoArray(out: WritableArrayLike<number>, offset?: number): void;
    readFromArray(arr: ArrayLike<number>, offset?: number): this;
}
declare class Vector3Base implements Vector3 {
    readonly array: Float32Array;
    constructor();
    constructor(array: ArrayLike<number>);
    constructor(x: number, y: number, z: number);
    toString(): string;
    static angle(vectorA: Vector3, vectorB: Vector3): number;
    get values(): Vector3Values;
    set values(values: Vector3Values);
    get x(): number;
    set x(x: number);
    get y(): number;
    set y(y: number);
    get z(): number;
    set z(z: number);
    setValues(x: number, y: number, z: number): this;
    copy(vec: Vector3): this;
    clone(): this;
    equals(vector: Vector3): boolean;
    setZeros(): this;
    setUnit(): this;
    add(vector: Vector3): this;
    addScalar(k: number): this;
    sub(vector: Vector3): this;
    lerp(from: Vector3, to: Vector3, t: number): this;
    max(vectorB: Vector3): this;
    min(vectorB: Vector3): this;
    clamp(min: Vector3, max: Vector3): this;
    scale(k: number): this;
    cross(vector: Vector3): this;
    dot(vec: Vector3): number;
    length(): number;
    lengthSquared(): number;
    distance(vec: Vector3): number;
    distanceSquared(vec: Vector3): number;
    normalize(): this;
    negate(): this;
    mult(mat: Matrix3): this;
    mult(vec: Vector3): this;
    toSpherical(center: Vector3): this;
    toCartesian(center: Vector3): this;
    static mult(mat: Matrix3, vec: Vector3): Vector3;
    writeIntoArray(out: WritableArrayLike<number>, offset?: number): void;
    readFromArray(arr: ArrayLike<number>, offset?: number): this;
    addScaled(vector: Vector3, k: number): this;
    copyAndSub(vecA: Vector3, vecB: Vector3): this;
    copyAndCross(vecA: Vector3, vecB: Vector3): this;
    [Symbol.iterator](): Iterator<number>;
}
declare var Vector3: Vector3Constructor;
declare const Vector3Injector: Injector<Vector3Constructor>;
